<!DOCTYPE html>
<html lang="ja">

<head>
  <script>console.log("(・ὢ・)見たな....")</script>
  <!-- LINE Tag Base Code -->
  <!-- Do Not Modify -->
  <!-- <script>
      (function (g, d, o) {
        g._ltq = g._ltq || []; g._lt = g._lt || function () { g._ltq.push(arguments) };
        var h = location.protocol === 'https:' ? 'https://d.line-scdn.net' : 'http://d.line-cdn.net';
        var s = d.createElement('script'); s.async = 1;
        s.src = o || h + '/n/line_tag/public/release/v1/lt.js';
        var t = d.getElementsByTagName('script')[0]; t.parentNode.insertBefore(s, t);
      })(window, document);
    _lt('init', {
      customerType: 'account',
      tagId: '31e6eaa0-0503-4711-9940-9716a1439ba6'
    });
    _lt('send', 'pv', ['31e6eaa0-0503-4711-9940-9716a1439ba6']);
  </script>
  <noscript>
    <img height="1" width="1" style="display:none" src="https://tr.line.me/tag.gif?c_t=lap&t_id=31e6eaa0-0503-4711-9940-9716a1439ba6&e=pv&noscript=1" />
  </noscript> -->
  <!-- End LINE Tag Base Code -->
  <!-- <script>
    _lt('send', 'cv', {
      type: 'Conversion'
    }, ['31e6eaa0-0503-4711-9940-9716a1439ba6']);
  </script> -->

  <title>冒険5.1</title>
  <meta charset="utf-8">
  <meta name="author" content="アヂョベ">
  <meta name="description" content="やあ">
  <meta name="keywords" content="本と箱の庭,冒険シリーズ,冒険,ああああ,勇者,ゆうしゃ,ユウシャ">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
  <link rel="icon" href="../assets/img/book.svg">
  <link rel="stylesheet" href="../assets/css/all_class_date.css">
  <link rel="stylesheet" href="../assets/css/details_class_description.css">
  <style>
    .none {
      display: none;
    }

    body {
      margin: 0;
    }

    #canvasWrapper {
      margin: 0;
      padding: 0;
      border-width: 0;
      width: 100vw;
      height: 100vw;
      box-sizing: border-box;
      position: relative;
    }

    #canvasWrapper canvas {
      margin: 0;
      padding: 0;
      border-width: 0;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      position: absolute;
      left: 0;
      top: 0;
    }

    #mainBody {
      margin: 10px;
    }
  </style>
</head>

<body>
  <noscript style="color: red; font: bold; font-size: 30vw;">Javascriptを有効にしてください</noscript>
  <div id="body" class="none">
    <header>
      <div class="date"></div>
    </header>
    <main>
      <div id="canvasWrapper">
        <canvas data-canvas-name="map">background map</canvas>
        <canvas data-canvas-name="building">background building</canvas>
        <canvas data-canvas-name="player">foreground character player</canvas>
        <canvas data-canvas-name="effect">foreground effect</canvas>
      </div>
      <div id="mainBody">
        <div>hello</div>
        <div><button onclick='action.start()'>start</button></div>
        <div><button onclick='action.stop()'>stop</button></div>
        <div><button onclick='action.changeFacing(action.getCell("player")[0], action.getCell("player")[1] ,1)'>左回転</button></div>
        <div><button onclick='action.changeFacing(action.getCell("player")[0], action.getCell("player")[1] ,3)'>右回転</button></div>
        <div><button onclick='action.changeFacing(action.getCell("player")[0], action.getCell("player")[1] ,2)'>反　転</button></div>
        <div><label>速さ<span>1.0</span><input type="range" min="100" max="1000" step="100" value="1000" onchange="this.previousElementSibling.innerHTML = ((now.speed = this.value) / 1000 + '.0').slice(0, 3);"></label>[second/block]</div>
      </div>
    </main>
  </div>
  <script src="../assets/js/all_class_date.js"></script>
  <script>
    document.getElementById("body").classList.remove("none");
    const Math2 = {
      num: (text = "", string = false, NaNzero = true) => {
        text = text.toString().replaceAll(/[^.\d]/g, "");
        if (NaNzero && text === "") {
          text = 0;
        }
        if (!string) {
          return parseFloat(text);
        } else {
          return text.toString();
        }
      },
      getRGB: (color = "black") => {
        let a = document.createElement("canvas").getContext("2d")
        a.fillStyle = color;
        if (typeof a.fillStyle !== "undefined") {
          return a.fillStyle;
        }
        return "#000000";
      },
      reverseColor: (color = "black") => {
        color = Math2.getRGB(color).match(/[^#]{2}/g);
        for (let i = 0; i < color.length; i++) {
          color[i] = zeroPadding((255 - parseInt(color[i], 16)).toString(16), 2);
        }
        return "#" + color.join("");
      },
      range: (min, max, ...number) => Math.min(min, Math.max(max, ...number)),
      transpose: array => array[0].map((col, i) => array.map(row => row[i])),
      uuid: () => {
        if ("crypto" in window && "getRandomValues" in window.crypto) {
          return Array.from(window.crypto.getRandomValues(new Uint8Array(32)), (x, i) => ((i == 8 || i == 12 || i == 16 || i == 20) ? "-" : "") + (i == 12 ? 4 : i == 16 ? (x % 4 + 8) : (x % 16)).toString(16)).join("");
        } else {
          let number = "";
          for (let i = 0; i < 32; i++) {
            let random = Math.floor(Math.random() * 16);
            if (i == 8 || i == 12 || i == 16 || i == 20) { number += "-"; }
            number += (i == 12 ? 4 : (i == 16 ? (random % 4 + 8) : random)).toString(16);
          }
          return number;
        }
      },
      mod: (num1, num2) => (num1 % num2 + num2) % num2,
    };
  </script>
  <script>
    const now = {
      grid: 12, //11マス 枠に1マス
      cell: undefined,
      reservationCell: undefined,
      select: "player",
      touch: { x: 0, y: 0, },
      count: 0,
      change: true,
      step: false, //start stop
      speed: 1000, //step speed
    };
    const component = {
      entity: {
        empty: {
        },
        player: {
        },
        star: {
        },
      },
      block: {
        wall: {
        },
      },
    };
    // class createEntity {
    //   constructor(x, y, name, facing) {
    //     let res = component.entity[name].before(x, y, name, facing);
    //     if (res[0]) {
    //       this.x = x;
    //       this.y = y;
    //       this.name = name;
    //       this.facing = facing; //→↑←↓
    //       now.cell[x][y] = this;
    //     }
    //     component.entity[name].after(this, res[1]);
    //   }
    //   static of(x = 0, y = 0, name = "empty", facing = 0) { return new this(x, y, name, facing); }
    // };
    const action = {
      getCell: (name = "player") => { //playerがいる座標を返す
        let number = [0, 0];
        number[0] = now.cell.findIndex(ele1 => ele1.some((ele2, index) => {
          let a = ele2.name == name;
          if (a) number[1] = index;
          return a;
        }));
        if (number[0] == -1) number[1] = -1;
        return number;
      },
      changeFacing: (x = 0, y = 0, turn = 1) => {
        now.cell[x][y].facing = Math2.mod(now.cell[x][y].facing + turn, 4);
        drow.character[now.cell[x][y].name](x, y, now.cell[x][y].facing);
      },
      start: () => {
        if (now.step === false) {
          now.change = false;
          now.step = true;
          step();
          return true;
        } else return false;
      },
      stop: () => {
        if (now.step === true) {
          now.change = true;
          now.step = false;
          return true;
        } else return false;
      },
    };
    const createComponent = {
      empty: (x = 0, y = 0) => {
        now.cell[x][y].name = "empty";
        now.cell[x][y].facing = 0;
      },
      player: (x = 0, y = 0, facing = 0) => {
        if (!/^(empty|player)$/.test(now.cell[x][y].name)) return false;
        let turn = now.cell[x][y].facing + facing;
        for (let i = 0; i < (now.grid - 1) ** 2; i++) {
          let cell = action.getCell("player");
          if (cell[0] == x && cell[1] == y) turn += 1;
          if (cell[0] == -1) {
            break;
          } else {
            createComponent.empty(cell[0], cell[1]);
          }
        }
        now.cell[x][y].name = "player";
        action.changeFacing(x, y, turn);
      },
      quadrilateral: (x = 0, y = 0) => {
        if (now.cell[x][y].name != "empty") return false;
        now.cell[x][y].name = "quadrilateral";
        drow.building.regularPolygon(x, y, 4);
      },
    };

    now.reservationCell = (now.cell = Array(now.grid - 1).fill().map((e1, x) => Array(now.grid - 1).fill().map((e2, y) => {
      return {
        x: x,
        y: y,
        name: "empty",
        facing: 0,
      }
    }))).slice(); //初期化
    // for (let i = 0; i < now.grid - 1; i++) {
    //   for (let j = 0; j < now.grid - 1; j++) {
    //     createEntity.of(i, j);
    //   }
    // } //初期化

    const step = () => {
      if (now.step) {
        now.count++;
        let playerCell = action.getCell("player");
        let playerFacing = now.cell[playerCell[0]][playerCell[1]].facing;
        let actionCell = playerCell;
        actionCell[0] += Math.round(Math.cos(Math.PI * playerFacing / 2));
        actionCell[1] -= Math.round(Math.sin(Math.PI * playerFacing / 2));
        if (!(actionCell[0] < 0 || actionCell[1] < 0 || actionCell[0] > now.grid - 2 || actionCell[1] > now.grid - 2)) {
          if (now.cell[playerCell[0]][playerCell[1]].name == "empty") {
            createComponent.player(actionCell[0], actionCell[1], playerFacing);
          }
        }
        setTimeout(step, now.speed);
      }
    }

    const getCanvas = name => canvasAll.find(element => element.name === name);
    const canvasWrapper = {
      element: document.getElementById("canvasWrapper"),
      left: document.getElementById("canvasWrapper").getBoundingClientRect().left,
      top: document.getElementById("canvasWrapper").getBoundingClientRect().top,
      width: document.getElementById("canvasWrapper").getBoundingClientRect().width,
      height: document.getElementById("canvasWrapper").getBoundingClientRect().height,
    };
    const canvasAll = [...document.querySelectorAll("canvas")];

    for (let i = 0; i < canvasAll.length; i++) {
      canvasAll[i] = {
        name: canvasAll[i].dataset.canvasName,
        canvas: canvasAll[i],
        ctx: canvasAll[i].getContext("2d"),
        left: Math2.num(canvasAll[i].getBoundingClientRect().left),
        top: Math2.num(canvasAll[i].getBoundingClientRect().top),
        width: Math2.num(canvasAll[i].getBoundingClientRect().width),
        height: Math2.num(canvasAll[i].getBoundingClientRect().height),
      };
      canvasAll[i].canvas.width = canvasAll[i].width;
      canvasAll[i].canvas.height = canvasAll[i].height;
      canvasAll[i].canvas.style.zIndex = i;
      canvasAll[i].ctx.clearRect(0, 0, canvasAll[i].width, canvasAll[i].height);
    }
    const drow = {
      block: (x = 0, y = 0) => {
        x = Math2.num(x);
        y = Math2.num(y);
        let width = canvasWrapper.width / (now.grid * 2);
        let height = canvasWrapper.height / (now.grid * 2);
        if (x >= 0 && x < now.grid - 1 && y >= 0 && y < now.grid - 1) {
          return [
            (1 + 2 * x) * width,
            (1 + 2 * y) * height,
            2 * width,
            2 * height
          ];
        } else return [width, height, 2 * width, 2 * height];
      },
      map: {
        first: () => {
          let ctx = getCanvas("map").ctx;
          let width = getCanvas("map").width;
          let height = getCanvas("map").height;
          let x = width / (now.grid * 2);
          let y = height / (now.grid * 2);
          ctx.fillStyle = "black";
          ctx.fillRect(0, 0, width, height);
          ctx.clearRect(x, y, (now.grid * 2 - 2) * x, (now.grid * 2 - 2) * y);
          for (let i = 0; i < now.grid - 1; i++) {
            for (let j = 0; j < now.grid - 1; j++) {
              ctx.strokeRect((1 + 2 * i) * x, (1 + 2 * j) * y, 2 * x, 2 * y);
            }
          }
        },
      },
      building: {
        clear: (x = 0, y = 0) => getCanvas("building").ctx.clearRect(...drow.block(x, y)),
        triangle: (x = 0, y = 0, color = "black") => {
          let ctx = getCanvas("building").ctx, xp = canvasWrapper.width / (now.grid * 4), yp = canvasWrapper.height / (now.grid * 4);
          drow.building.clear(x, y);
          [x, y] = drow.block(x, y);
          ctx.fillStyle = Math2.getRGB(color);
          ctx.beginPath();
          ctx.moveTo(x + 2 * xp, y + yp);
          ctx.lineTo(x + xp, y + 3 * yp);
          ctx.lineTo(x + 3 * xp, y + 3 * yp);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.stroke();
        },
        multiplication: (x = 0, y = 0, color = "black") => {
          let ctx = getCanvas("building").ctx, xp = canvasWrapper.width / (now.grid * 8), yp = canvasWrapper.height / (now.grid * 8);
          drow.building.clear(x, y);
          [x, y] = drow.block(x, y);
          ctx.fillStyle = Math2.getRGB(color);
          ctx.beginPath();
          ctx.moveTo(x + 1 * xp, y + 2 * yp);
          ctx.lineTo(x + 2 * xp, y + 1 * yp);
          ctx.lineTo(x + 4 * xp, y + 3 * yp);
          ctx.lineTo(x + 6 * xp, y + 1 * yp);
          ctx.lineTo(x + 7 * xp, y + 2 * yp);
          ctx.lineTo(x + 5 * xp, y + 4 * yp);
          ctx.lineTo(x + 7 * xp, y + 6 * yp);
          ctx.lineTo(x + 6 * xp, y + 7 * yp);
          ctx.lineTo(x + 4 * xp, y + 5 * yp);
          ctx.lineTo(x + 2 * xp, y + 7 * yp);
          ctx.lineTo(x + 1 * xp, y + 6 * yp);
          ctx.lineTo(x + 3 * xp, y + 4 * yp);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.stroke();
        },
        cross: (x = 0, y = 0, color = "black") => {
          let ctx = getCanvas("building").ctx, xp = canvasWrapper.width / (now.grid * 8), yp = canvasWrapper.height / (now.grid * 8);
          drow.building.clear(x, y);
          [x, y] = drow.block(x, y);
          ctx.fillStyle = Math2.getRGB(color);
          ctx.beginPath();
          ctx.moveTo(x + 1 * xp, y + 2 * yp);
          ctx.lineTo(x + 3 * xp, y + 2 * yp);
          ctx.lineTo(x + 3 * xp, y + 1 * yp);
          ctx.lineTo(x + 5 * xp, y + 1 * yp);
          ctx.lineTo(x + 5 * xp, y + 2 * yp);
          ctx.lineTo(x + 7 * xp, y + 2 * yp);
          ctx.lineTo(x + 7 * xp, y + 4 * yp);
          ctx.lineTo(x + 5 * xp, y + 4 * yp);
          ctx.lineTo(x + 5 * xp, y + 7 * yp);
          ctx.lineTo(x + 3 * xp, y + 7 * yp);
          ctx.lineTo(x + 3 * xp, y + 4 * yp);
          ctx.lineTo(x + 1 * xp, y + 4 * yp);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.stroke();
        },
        pentagon: (x = 0, y = 0, color = "black") => {
          let ctx = getCanvas("building").ctx, xp = canvasWrapper.width / (now.grid * 6), yp = canvasWrapper.height / (now.grid * 6);
          drow.building.clear(x, y);
          [x, y] = drow.block(x, y);
          ctx.fillStyle = Math2.getRGB(color);
          ctx.beginPath();
          ctx.moveTo(x + (3 + 2 * Math.cos(1 * Math.PI / 10)) * xp, y + (3 - 2 * Math.sin(1 * Math.PI / 10)) * yp);
          ctx.lineTo(x + (3 + 2 * Math.cos(5 * Math.PI / 10)) * xp, y + (3 - 2 * Math.sin(5 * Math.PI / 10)) * yp);
          ctx.lineTo(x + (3 + 2 * Math.cos(9 * Math.PI / 10)) * xp, y + (3 - 2 * Math.sin(9 * Math.PI / 10)) * yp);
          ctx.lineTo(x + (3 + 2 * Math.cos(13 * Math.PI / 10)) * xp, y + (3 - 2 * Math.sin(13 * Math.PI / 10)) * yp);
          ctx.lineTo(x + (3 + 2 * Math.cos(17 * Math.PI / 10)) * xp, y + (3 - 2 * Math.sin(17 * Math.PI / 10)) * yp);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.stroke();
        },
        regularPolygon: (x = 0, y = 0, vertex = 3, color = "black") => {
          let ctx = getCanvas("building").ctx, xp = canvasWrapper.width / (now.grid * 6), yp = canvasWrapper.height / (now.grid * 6);
          drow.building.clear(x, y);
          [x, y] = drow.block(x, y);
          vertex = (vertex = Math2.num(vertex)) < 3 ? 3 : vertex > 8 ? 8 : vertex;
          ctx.fillStyle = Math2.getRGB(color);
          ctx.beginPath();
          ctx.moveTo(x + 3 * xp, y + yp);
          for (let i = 1; i < vertex; i++) {
            ctx.lineTo(x + (3 + 2 * Math.cos((vertex + 4 * i) * Math.PI / (2 * vertex))) * xp, y + (3 - 2 * Math.sin((vertex + 4 * i) * Math.PI / (2 * vertex))) * yp);
          }
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.stroke();
        },
        triangle: (x = 0, y = 0, color = "black") => {
          let ctx = getCanvas("building").ctx, xp = canvasWrapper.width / (now.grid * 4), yp = canvasWrapper.height / (now.grid * 4);
          drow.building.clear(x, y);
          [x, y] = drow.block(x, y);
          ctx.fillStyle = Math2.getRGB(color);
          ctx.beginPath();
          ctx.moveTo(x + 2 * xp, y + 1 * yp);
          ctx.lineTo(x + 1 * xp, y + 3 * yp);
          ctx.lineTo(x + 3 * xp, y + 3 * yp);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.stroke();
        },
        triangle: (x = 0, y = 0, color = "black") => {
          let ctx = getCanvas("building").ctx, xp = canvasWrapper.width / (now.grid * 4), yp = canvasWrapper.height / (now.grid * 4);
          drow.building.clear(x, y);
          [x, y] = drow.block(x, y);
          ctx.fillStyle = Math2.getRGB(color);
          ctx.beginPath();
          ctx.moveTo(x + 2 * xp, y + 1 * yp);
          ctx.lineTo(x + 1 * xp, y + 3 * yp);
          ctx.lineTo(x + 3 * xp, y + 3 * yp);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.stroke();
        },
        quadrilateral: (x = 0, y = 0) => {
          let ctx = getCanvas("building").ctx, xp = canvasWrapper.width / (now.grid * 4), yp = canvasWrapper.height / (now.grid * 4);
          drow.building.clear(x, y);
          [x, y] = drow.block(x, y);
          ctx.fillStyle = "black";
          ctx.beginPath();
          ctx.moveTo(x + 2 * xp, y + yp);
          ctx.lineTo(x + xp, y + 3 * yp);
          ctx.lineTo(x + 3 * xp, y + 3 * yp);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = "black";
          ctx.stroke();
        },
      },
      character: {
        player: (x = 0, y = 0, theta = 0) => {
          theta = Math.max(0, Math.floor(Math2.num(theta))) % 4;
          const canvas = getCanvas("player");
          let ctx = canvas.ctx;
          let grid = 4;
          let width = canvas.width / now.grid / grid;
          let height = canvas.height / now.grid / grid;
          x = (x + 0.5) * width * grid;
          y = (y + 0.5) * height * grid;
          ctx.save();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "black";
          ctx.translate(x + width * grid / 2, y + height * grid / 2);
          ctx.rotate(-Math.PI / 2 * theta);
          ctx.translate(-(x + width * grid / 2), -(y + height * grid / 2));
          ctx.beginPath();
          ctx.moveTo(x + width * 3, y + width * 2);
          ctx.lineTo(x + width * 1, y + width * 1);
          ctx.lineTo(x + width * 1, y + width * 3);
          ctx.fill();
          ctx.restore();
        },
      },
      effect: {
        hoge: () => {
        },
      },
    };
    drow.map.first();

    canvasWrapper.element.addEventListener("touchstart", (event) => {
      let x = Math.floor((event.changedTouches[0].pageX - canvasWrapper.left) / (canvasWrapper.width / (now.grid * 2)));
      let y = Math.floor((event.changedTouches[0].pageY - canvasWrapper.top) / (canvasWrapper.height / (now.grid * 2)));
      if (!(x > 0 && x < (now.grid * 2 - 1) && y > 0 && y < (now.grid * 2 - 1))) return;
      x = Math.floor((x - 1) / 2);
      y = Math.floor((y - 1) / 2);
      console.log({ x: x, y: y });
    });
    canvasWrapper.element.addEventListener("touchmove", (event) => {
      event.preventDefault();
      let x = Math.floor((event.changedTouches[0].pageX - canvasWrapper.left) / (canvasWrapper.width / (now.grid * 2)));
      let y = Math.floor((event.changedTouches[0].pageY - canvasWrapper.top) / (canvasWrapper.height / (now.grid * 2)));
      if (!(x > 0 && x < (now.grid * 2 - 1) && y > 0 && y < (now.grid * 2 - 1))) return;
      x = Math.floor((x - 1) / 2);
      y = Math.floor((y - 1) / 2);
      if (now.touch.x == x && now.touch.y == y) return;
      now.touch.x = x;
      now.touch.y = y;
      console.log({ x: x, y: y });
      if (now.change) createComponent[now.select](x, y, 3);
    });
    canvasWrapper.element.addEventListener("touchend", (event) => {
      let x = Math.floor((event.changedTouches[0].pageX - canvasWrapper.left) / (canvasWrapper.width / (now.grid * 2)));
      let y = Math.floor((event.changedTouches[0].pageY - canvasWrapper.top) / (canvasWrapper.height / (now.grid * 2)));
      if (!(x > 0 && x < (now.grid * 2 - 1) && y > 0 && y < (now.grid * 2 - 1))) return;
      x = Math.floor((x - 1) / 2);
      y = Math.floor((y - 1) / 2);
      console.log({ x: x, y: y });
      if (now.change) createComponent[now.select](x, y);
    });

    createComponent.player();

    // canvasWrapper.element.addEventListener("mousedown", (event) => {
    //   let x = Math.floor((event.pageX - canvasWrapper.left) / (canvasWrapper.width / 16));
    //   let y = Math.floor((event.pageY - canvasWrapper.top) / (canvasWrapper.height / 16));
    //   if (!(x > 0 && x < 15 && y > 0 && y < 15)) {
    //     return;
    //   }
    //   now.touch.start.x = x = Math.floor((x - 1) / 2);
    //   now.touch.start.y = y = Math.floor((y - 1) / 2);
    //   if (now.player.x == x && now.player.y == y) {
    //     now.touch.canMove = true;
    //     drow.character.player(x, y);
    //   } else {
    //     now.touch.canMove = false;
    //   }
    //   console.log({ x: x, y: y });
    // });
    // canvasWrapper.element.addEventListener("mousemove", (event) => {
    //   event.preventDefault();
    //   if (now.touch.canMove) {
    //     let x = Math.floor((event.pageX - canvasWrapper.left) / (canvasWrapper.width / 16));
    //     let y = Math.floor((event.pageY - canvasWrapper.top) / (canvasWrapper.height / 16));
    //     if (!(x > 0 && x < 15 && y > 0 && y < 15)) return;
    //     x = Math.floor((x - 1) / 2);
    //     y = Math.floor((y - 1) / 2);
    //     if (now.touch.move.x == x && now.touch.move.y == y) return;
    //     now.player.x = now.touch.move.x = x;
    //     now.player.y = now.touch.move.y = y;
    //     drow.character.player(x, y);
    //     console.log({ x: x, y: y });
    //   }
    // });
    // canvasWrapper.element.addEventListener("mouseup", (event) => {
    //   let x = Math.floor((event.pageX - canvasWrapper.left) / (canvasWrapper.width / 16));
    //   let y = Math.floor((event.pageY - canvasWrapper.top) / (canvasWrapper.height / 16));
    //   if (!(x > 0 && x < 15 && y > 0 && y < 15)) {
    //     return;
    //   }
    //   x = Math.floor((x - 1) / 2);
    //   y = Math.floor((y - 1) / 2);
    //   console.log({ x: x, y: y });
    // });
    // canvasWrapper.element.addEventListener("mouseleave", () => {
    // })
  </script>
</body>

</html>